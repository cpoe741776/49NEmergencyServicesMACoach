// src/services/openai-integration.ts
import type { MentalArmorSkill } from "@/types/emergency";
import { MENTAL_ARMOR_SKILLS } from "@/data/skills";
import { getOpenAIConfig } from "../config/environment";
import {
  OPENAI_CONFIG,
  EMERGENCY_KEYWORDS,
  CRISIS_KEYWORDS,
} from "@/config/repair-kit-config";

// ----------------- Types -----------------
export type ChatMsg = {
  role: "user" | "assistant" | "system";
  content: string;
};

export type CoachPersona = {
  name: string;
  style?: string;
  guardrails?: string[];
};

export type CoachResponse = {
  text: string;
  suggestedSkillIds?: string[];
  suggestionRationale?: string;
  /** legacy duplicate for older callers */
  content?: string;
  /** lets UI show the emergency banner immediately */
  requiresEscalation?: boolean;
};

// ----------------- Env + Model -----------------
const __ENV_OPENAI = getOpenAIConfig();
const OPENAI_API_KEY = __ENV_OPENAI.apiKey || "";
const MODEL = __ENV_OPENAI.model || "gpt-4o-mini";
const BASE_URL = "https://api.openai.com/v1";

// ----------------- Helpers -----------------
/** Use your Repair Kit systemPrompt + our strict catalog guardrails */
function buildSystemPrompt(coach?: CoachPersona): string {
  const skillList = MENTAL_ARMOR_SKILLS.map(s => `- ${s.id}: ${s.title}`).join("\n");

  const coachHat = coach?.name
    ? `You are "${coach?.name}", a Mental Armor™ coach. ${coach?.style ?? ""}`.trim()
    : `You are a Mental Armor™ coach.`;

  const guardrails = [
    "Use only Mental Armor™ terminology and skills present in the provided catalog.",
    "Do not invent new skills, exercises, modules, or claims.",
    "Be conversational and practical; give short, usable steps.",
    "When referencing a skill, include its exact id when helpful.",
    "Prefer British English spellings when ambiguous.",
    ...(coach?.guardrails ?? []),
  ].map(x => `- ${x}`).join("\n");

  // Pull the high-level role + safety language from repair-kit-config.ts
  const trainingPrompt = OPENAI_CONFIG?.systemPrompt?.trim() || "";

  return [
    trainingPrompt,            // from repair-kit-config.ts
    "",
    coachHat,                  // persona
    "",
    "CATALOG OF MENTAL ARMOR™ SKILLS (id → title):",
    skillList,
    "",
    "Guardrails:",
    guardrails,
  ].join("\n");
}

function tokenize(s: string): string[] {
  return s.toLowerCase().replace(/[^a-z0-9\s]/g, " ").split(/\s+/).filter(Boolean);
}

function pickRelevantSkillsLocally(text: string, max = 3): string[] {
  const q = text.toLowerCase();
  const scored: Array<{ id: string; score: number }> = [];

  for (const s of MENTAL_ARMOR_SKILLS) {
    const hay = [
      s.id,
      s.title,
      ...(s.modules ?? []),
      ...(s.domains ?? []),
      s.goal ?? "",
      s.whenToUse ?? "",
      ...(s.benefits ?? []),
    ].join(" ").toLowerCase();

    let score = 0;
    for (const token of tokenize(q)) if (hay.includes(token)) score += 1;
    if (q.length <= 140 && hay.includes(q)) score += 2;

    if (score > 0) scored.push({ id: s.id, score });
  }

  scored.sort((a, b) => b.score - a.score);
  return scored.slice(0, max).map(s => s.id);
}

function sanitizeSkillIds(ids: string[] | undefined): string[] | undefined {
  if (!ids?.length) return undefined;
  const allow = new Set(MENTAL_ARMOR_SKILLS.map(s => s.id));
  const uniq = Array.from(new Set(ids)).filter(id => allow.has(id));
  return uniq.length ? uniq : undefined;
}

/** Use your CRISIS_KEYWORDS/EMERGENCY_KEYWORDS to decide if UI should escalate */
function detectRequiresEscalation(input: string): boolean {
  const t = input.toLowerCase();

  // Any emergency keyword → escalate
  if (EMERGENCY_KEYWORDS.some(k => t.includes(k.toLowerCase()))) return true;

  // Any CRITICAL or HIGH match → escalate
  const crit = (CRISIS_KEYWORDS.CRITICAL || []).some(k => t.includes(k.toLowerCase()));
  const high = (CRISIS_KEYWORDS.HIGH || []).some(k => t.includes(k.toLowerCase()));
  return crit || high;
}

// ----------------- Model call -----------------
type ModelMessage = { role: "system" | "user" | "assistant"; content: string };

async function callOpenAI(messages: ModelMessage[]) {
  if (!OPENAI_API_KEY) {
    // Fail fast with a helpful message if key missing
    return `{"suggestedSkillIds":[],"rationale":"Demo mode (no API key)"}\nI’m in demo mode, so here’s a quick practice step: pick a small situation today and apply one Mental Armor™ skill (e.g., Mindfulness 90s breath, or ReFrame one negative thought).`;
  }

  const res = await fetch(`${BASE_URL}/chat/completions`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${OPENAI_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: MODEL,
      temperature: 0.4,
      // ask model for a leading JSON header line (we parse it below)
      response_format: { type: "text" },
      messages,
    }),
  });

  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`OpenAI error ${res.status}: ${t || res.statusText}`);
  }
  const data = await res.json();
  return data?.choices?.[0]?.message?.content ?? "";
}

// ----------------- Public API -----------------
export async function getCoachResponse(opts: {
  history: ChatMsg[];
  userTurn: string;
  coach?: CoachPersona;
  allowSuggestions?: boolean;
}): Promise<CoachResponse> {
  const { history, userTurn, coach, allowSuggestions = true } = opts;

  const sys = buildSystemPrompt(coach);
  const protocol = [
    "FIRST, if skill suggestions are appropriate, begin your reply with a one-line JSON header:",
    `{"suggestedSkillIds":["<id1>","<id2>"],"rationale":"<short reason>"}`,
    "Only use ids from the catalog above. If none, return {}.",
    "THEN, on a new line, provide your coaching response for the user.",
  ].join(" ");

  const messages: ModelMessage[] = [
    { role: "system", content: sys },
    { role: "user", content: `Protocol: ${protocol}` },
    ...history.map(m => ({ role: m.role, content: m.content }) as ModelMessage),
    { role: "user", content: userTurn },
  ];

  const localSuggestion = allowSuggestions ? pickRelevantSkillsLocally(userTurn) : [];

  const raw = await callOpenAI(messages);

  let suggestedSkillIds: string[] | undefined;
  let suggestionRationale: string | undefined;
  let text = raw;

  const firstLine = raw.split(/\r?\n/, 1)[0]?.trim();
  if (firstLine?.startsWith("{") && firstLine?.endsWith("}")) {
    try {
      const header = JSON.parse(firstLine) as {
        suggestedSkillIds?: string[];
        rationale?: string;
      };
      suggestedSkillIds = sanitizeSkillIds(header.suggestedSkillIds);
      suggestionRationale = header?.rationale?.toString()?.slice(0, 280);
      text = raw.slice(firstLine.length).replace(/^\s*\r?\n/, "");
    } catch {
      // ignore parse errors; we’ll fall back to local suggestion
    }
  }

  if (allowSuggestions && (!suggestedSkillIds || suggestedSkillIds.length === 0)) {
    suggestedSkillIds = sanitizeSkillIds(localSuggestion);
    suggestionRationale ||= "Matched to your message using the Mental Armor™ catalog.";
  }

  const payload: CoachResponse = {
    text: text.trim(),
    suggestedSkillIds,
    suggestionRationale,
  };

  // legacy + UI helpers
  payload.content = payload.text;
  payload.requiresEscalation = detectRequiresEscalation(userTurn);

  return payload;
}

// Convenience: expose catalog (read-only)
export function getSkillCatalog(): Readonly<MentalArmorSkill[]> {
  return MENTAL_ARMOR_SKILLS;
}

// --- Back-compat wrapper for older callers (e.g., RepairKit.tsx) -------------
export type CreateAIConfig =
  | string
  | { coach?: CoachPersona; allowSuggestions?: boolean };

export function createMentalArmorAI(config?: CreateAIConfig) {
  let coach: CoachPersona | undefined;
  let allowSuggestions = true;

  if (typeof config === "string") {
    coach = { name: config };
  } else if (config) {
    coach = config.coach;
    allowSuggestions = config.allowSuggestions ?? true;
  }

  async function core(userText: string, history: ChatMsg[]) {
    return getCoachResponse({ history, userTurn: userText, coach, allowSuggestions });
  }

  return {
    async send(userText: string, history: ChatMsg[]) {
      return core(userText, history);
    },
    // Accepts 2 or 3 args: (userText, history) OR (userText, context, history)
    async generateResponse(...args: unknown[]) {
      if (args.length === 2) {
        const [a, b] = args;
        return core(a as string, b as ChatMsg[]);
      }
      if (args.length === 3) {
        const [a, , c] = args; // ignore context
        return core(a as string, c as ChatMsg[]);
      }
      const userText = (args.find(x => typeof x === "string") ?? "") as string;
      const history = (args.find(x => Array.isArray(x)) ?? []) as ChatMsg[];
      return core(userText, history);
    },
  };
}

// Add these exports at the very end of your src/config/repair-kit-config.ts file

// Export the constants that are being imported
export { DEFAULT_EMERGENCY_RESOURCES };
export { EMERGENCY_KEYWORDS };
export { CRISIS_KEYWORDS };

// Fix the type issues for array methods
export const EMERGENCY_KEYWORDS_TYPED = EMERGENCY_KEYWORDS as string[];
export const CRISIS_KEYWORDS_TYPED = {
  CRITICAL: CRISIS_KEYWORDS.CRITICAL as string[],
  HIGH: CRISIS_KEYWORDS.HIGH as string[],
  MEDIUM: CRISIS_KEYWORDS.MEDIUM as string[],
  LOW: CRISIS_KEYWORDS.LOW as string[]
};
